# Пользовательские библиотеки платформы AXCode

## Описание

Общедоступная библиотека функций для пользователей устройств на платформе **AXCode**, наполняемая программистами ПЛК.

Исходный код библиотеки доступен только для внутреннего пользования. Конечному пользователю библиотека поставляется в виде скомпилированных библиотек и заголовочных файлов.


## Правила добавления компонентов в библиотеку

*Пример создания функционального блока типа `Execute` по данным правилам находится в файлах `example/include/ulib/example/fb_etriga_example.h` и `example/src/fb_etriga_example.cpp`*

1. Для добавления/исправления компонентов библиотеки в git создается новая ветка от последней версии ветки `main`.
2. По готовности компонента в GitLab создается мердж-реквест на слияние ветки с `main`. В основную ветку код попадет после проверки.
3. При добавлении новых файлов:
   1. Заголовочные файлы располагать в папке `include/ulib`. Например,
      ```
      include/ulib/fb_triggers.h
      ```
   2. В `#include` путь прописывается вместе с папкой `ulib`. Например,
      ```cpp
      #include "ulib/fb_triggers.h"
      ```
   3. Заголовочный файл включается в `ulib.h` в виде `#include "ulib/new_file.h`. Файлы желательно располагать в алфавитном порядке
   4. Файлы с исходным кодом располагать в папке `src`. Например,
      ```
      src/fb_triggers.cpp
      ```
   5. Путь к файлу с исходным кодом добавить в `CMakeLists.txt` в папке библиотеки. Путь указывается относительно папки с библиотекой. Файл добавляется в функцию `add_library()`. Например:
      ```cmake
      add_library(${PROJECT_NAME}
        src/fb_triggers.cpp
        src/new_code.cpp # Новый добавленный файл
      )
      ```
   6. Файл начинается с комментария Doxygen с именем файла и кратким описанием.
      ```
      /**
       * \file new_code.cpp
       * \brief Краткое описание содержимого файла
       */
      ```
   7. И в файле с исходным кодом, и в заголовочном файле весь код, кроме `#include` и `#define` помещается в `namespace plc{ /*... */}`.
      Для дефайнов нужно использовать уникальное имя, не пересекающееся с другими. Обычно для этого добавляется префикс с названием компонента. Например,
      ```cpp
      #include "ulib/new_code.h"
      #define NEW_CODE_SOME_CONSTANT (1)

      namespace plc
      {
        // Код файла
      }
      ```
4. Правила наименования компонентов:
   1. Классы и функции назваются в стиле `CamelCase`
   2. Переменные класса называются в стиле `snake_case`
   3. Методы класса называются в стиле `lowerCamelCase`.
      1. *Методы выходных параметров функциональных блоков допускается называть в стиле `snake_case`, т.к. для пользователя они только выводят переменную, которую он не может изменить без запуска функционального блока. См. пример работы с функциональными блоками.*
   4. Макросы и перечисления называются в стиле `UPPER_CASE`
   5. Файлы называются в стиле `snake_case`
   6. Если в названии присутствует аббревиатура, для улучшения читаемости после нее можно добавить `_`. Например, `PLC_SomeClass`.
   7. Название заголовочного файла должно совпадать с названием файла с исходным кодом, к которому относится заголовочный файл
5. Для описания переменных/методов/классов и т.д. используются комментарии в стиле Doxygen. Примеры:
   ```cpp
   //! Краткое описание переменной "a" в одну строку
   int a;
   int b; //!< Краткое описание переменной "b" в одну строку

   /**
    * \brief Краткое описание функции c()
    * \param d Описание аргумента "d"
    * \param e Описание аргумента "e"
    * \details
    * Подробное описание функции c()
    * \return Описание возвращаемых значений функции (в общем виде)
    * \retval true Описание конкретного возвращаемого значения
    * \retval false Описание другого возвращаемого значения
    */
   bool c(int d, int e)
   {
     // ...
   }
   ```
6. Добавляемые компоненты должны являться функциональными блоками, кроме особых случаев.
   В файлы с функциональным блоком включается базовый файл с описанием функциональных блоков из библиотек ядра:
   ```cpp
   #include "plc/fb_base.h"
   ```
7. Функциональные блоки должны представлять собой ФБ типа `Execute` или `Enable` (см. описание классов в файле `plc/fb_base.h`) за исключением простых операций с минимумом действий, выполняемых за один цикл (например, таким блоком является триггер переднего фронта `plc::RTrig`).  
   Такие ФБ желательно наследовать от класса `plc::FunctionalBlock` (потребуется в будущем для среды разработки). Для выполнения блоков нужно обязательно добавить в класс публичный метод `void operator()();`, в котором реализовывается логика блока. Для этого в объявление класса добавляется:
   ```cpp
   namespace plc
   {
     class NewFunctionalBlock : public FunctionalBlock
     {
     public:
       void operator()(); //!< Метод выполнения блока
       // ...
     };
   }
   ```
8. Все входные параметры функционального блока должны быть публичными переменными (идти в классе после ключевого слова `public:`).  
   Все выходные параметры должны быть публичными методами. Остальные переменные должны быть `private` (если доступ к переменной есть только у данного функционального блока) или `protected` (если доступ к переменной могут получить наследники класса функционального блока).  
   *Примечание. Методы выходных параметров обычно имеют модификатор `const` после аргументов метода т.к. не изменяют состояние блока, а только выдают значение переменной.*
   Приватные переменные начинаются с `_` (одинарное подчеркивание), приватные методы - с `__` (двойное подчеркивание) Например:
   ```cpp
   class NewFunctionalBlock : public FunctionalBlock
   {
   public:
     bool in_parameter; //!< Входной параметр
     bool out() const; //!< Выходной параметр

     void operator()(); //!< Метод выполнения блока (всегда публичный)

     NewFunctionalBlock(); //!< Конструктор класса (всегда публичный)

   private:
     bool _private_variable;
     bool __privateMethod();
   };
   ```
9.  Доступные пользователю (публичные) переменнные и параметры должны идти первыми в объявлении класса.
10. Все требуемые для работы фунционального блока переменные и/или другие функциональные блоки, если они всегда используются в ФБ и влияют на работу только данного ФБ, включаются в класс функционального блока как private или protected.  
   Вызов данных блоков должен будет осуществляться внутри кода основного блока. Например:
    ```cpp
    class NewFunctionalBlock : public FunctionalBlock
    {
    public:
     // ...

    private:
     RTrig _trigger;
     ETrig _block;
    };
    ```
11. Для настройки параметров блока при инициализации внутри класса после ключевого слова `protected:` объявляется структура `Init`, которая дублирует все входные параметры блока. 
   Структура передается по ссылке на константу (`const Init& init`) в конструктор блока и присваивает свои значения всем входным переменным. 
   Значения входных параметров по умолчанию задаются внутри данной структуры. 
   Структура объявляется до конструктора. Например:
    ```cpp
    // .h файл
    class NewFunctionalBlock : public ETrig
    {
    public:
      bool a; //!< Описание входного параметра a
      bool b; //!< Описание входного параметра b
      bool c; //!< Описание входного параметра c

    protected:
      struct Init
      {
        bool a = false; //!< Описание входного параметра a
        bool b = true;  //!< Описание входного параметра b
        bool c = false; //!< Описание входного параметра c
      };

    public:
      NewFunctionalBlock(const Init& init);

      // ...
    };

    // .cpp файл
    NewFunctionalBlock::NewFunctionalBlock(const Init& init)
    : a{init.a}, // После ":" идет присвоение начальных значений переменным класса,
      b{init.b}, // в т.ч. константам. Также здесь могут быть присвоены приватные
      c{init.c}  // и прочие переменные класса
    {
    }
    ```
12. Внутри библиотеки **ЗАПРЕЩЕНО** объявлять глобальные или статические переменные, за исключением случаев, когда такая переменная может быть только одна на весь проект при использовании нескольких экземпляров компонента одновременно.
13. Описание функционального блока помещается в комментарий в стиле Doxygen перед объявлением класса. Например:
    ```cpp
    /**
     * \brief Краткое описание блока
     * \details
     * Подробное описание работы блока
     */
    class NewFunctionalBlock : public FunctionalBlock
    {
      // ...
    };
    ```
14. Комментарии с описанием доступных пользователю классов, функций, переменных и т.д. помещаются в заголовочный файл. Описание приватных функций/методов помещается в .cpp файл.
15. Библиотека должна быть независимой от конкретных модификаций Alpha-X и других модификаций процессорного модуля. В библиотеке не должны использоваться заголовочные файлы `pou_manager.h` и `system_api.h`
16. Библиотека должна преимущественно использовать доступные пользователю функции библиотек ядра (в основном библиотеки `plc`). Подключение сторонних библиотек должно осуществляться по согласованию.
